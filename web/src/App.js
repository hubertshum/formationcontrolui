import React from "react";
import Header from "./Header.js";
import Footer from "./Footer.js";
import PlotlyFig from "./Visualisation.js";
import Instructions from "./Instructions.js";
import "bootstrap/dist/css/bootstrap.css";
import "./App.css";

function query_builder(url, params) {
  // function to build query strings for hashmap
  let query = Object.keys(params)
    .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
    .join("&");

  let qUrl = url + "?" + query;
  return qUrl;
}

function About() {
  return (
    <div className="container">
      <div className="space-up-down">
        <h3>Flux Guiding Algorithm</h3>
        <p>
          Flux guiding is formation control algorithm for guiding formations of
          UAVs toward a remote target. The algorithm is packaged{" "}
          <a href="https://gitfront.io/r/johnmatthewhartley/c81e9e54cb2749d718e54ae6517bca517097e1ae/formationplanning/">
            here
          </a>
          . Check out the paper{" "}
          <a href="https://arxiv.org/abs/2103.09184">here</a>.
        </p>
        <p>
          Trajectories are generated by maximizing the sum of an electric field
          or flux across formation's surface generated by a remote target. Since
          the electric field is harmonic the formation orientates itself toward
          the target and tracks it. The formation maintains optimal coverge of
          the target.
        </p>
        <p>
          Typically formation control algorithms must solve a high dimensional
          optimisation algorithm to generate trajectories. Flux guiding is
          different. The domain is low dimensional since only the UAVs on the
          front face of the formation are required to measure the flux across
          the formations surface. This makes the algorithm ideal to generate
          trajectories for a large number of UAVs.
        </p>
      </div>
    </div>
  );
}

function Intro() {
  return (
    <p className="lead">
      Simulate the motion of a formation of UAVs tasked with surrounding a
      remote target.
    </p>
  );
}

class Slider extends React.Component {
  constructor(props) {
    super(props);
    this.state = { value: 0 };
  }

  render() {
    return (
      <div>
        <label className="form-label">
          {this.props.name}: {this.props.value}
        </label>
        <input
          step="1"
          value={this.props.value}
          min={this.props.min}
          max={this.props.max}
          type="range"
          className="form-range blue-dial"
          onChange={(e) => this.props.onChange(e)}
        />
      </div>
    );
  }
}

class UpdateButton extends React.Component {
  render() {
    //let msg = this.props.loading ? 'Running...': 'Run'
    return (
      <div className="p-bottom p-top">
        <button
          type="button"
          className="jh-btn-primary btn btn-primary"
          onClick={(e) => this.props.onClick(e)}
        >
          {this.props.loading}
        </button>
      </div>
    );
  }
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      // default values for the sliders
      values: [10, -20, 20, 5, 0, 0, 0, 5],
      // min values for the sliders
      min: [-50, -50, -50, 1, 0, 0, 0, 5],
      // max values for the sliders
      max: [50, 50, 50, 20, 50, 50, 50, 10],
      // names for the sliders
      names: [
        "Target X",
        "Target Y",
        "Target Z",
        "Target Radius",
        "Formation X",
        "Formation Y",
        "Formation Z",
        "Formation Scale",
      ],
      // the data for the uav trajectories
      trajectoryData: null,
      // message for whether we are loading trajectory data
      loading: "",
    };
  }

  handleChange(i, e) {
    // handle slider change event
    const values = this.state.values.slice();
    values[i] = parseInt(e.target.value, 10);
    this.setState({ values: values });
    e.target.blur();
  }

  handleButtonClick(e) {
    // handle the button click event
    this.fetchTrajectoryData();
    e.target.blur();
  }

  figureLoaded() {
    // run when Plotly digure has been updated.
    this.setState({ loading: "Generate" });
  }

  fetchTrajectoryData() {
    // ajax request for trajectory data
    this.setState({ loading: "Loading..." });

    let params = {
      target: this.state.values.slice(0, 3),
      formation: this.state.values.slice(4, 7),
      r: this.state.values.slice(3, 4),
      sep: this.state.values.slice(7),
    };

    let url = query_builder("/api/xt", params);

    fetch(url)
      .then((response) => {
        if (!response.ok) {
          throw Error(response.statusText);
        }
        return response.json();
      })
      .then(
        this.setState({
          target: params["target"],
          r: params["r"],
        })
      )
      .then((data) => this.setState({ trajectoryData: data["trajectory"] }))
      .catch((error) => {
        if (process.env.NODE_ENV === "development") {
          console.error(error);
        }
      });
  }

  renderRange(i) {
    // helper function to render the slider
    return (
      <Slider
        name={this.state.names[i]}
        value={this.state.values[i]}
        onChange={(e) => this.handleChange(i, e)}
        min={this.state.min[i]}
        max={this.state.max[i]}
      />
    );
  }

  componentDidMount() {
    // after render then load some data for the user.
    this.fetchTrajectoryData();
  }

  render() {
    return (
      <div className="App">
        <Header />
        <div className="container space-up-down">
          <Intro />
          <div className="row">
            <div className="col-sm-2">
              {this.renderRange(0)}
              {this.renderRange(1)}
              {this.renderRange(2)}
              {this.renderRange(3)}
              {this.renderRange(4)}
              {this.renderRange(5)}
              {this.renderRange(6)}
              {this.renderRange(7)}
              <UpdateButton
                onClick={(e) => this.handleButtonClick(e)}
                loading={this.state.loading}
              />
            </div>
            <div className="col-sm-10">
              <PlotlyFig
                onChange={() => this.figureLoaded()}
                tdata={this.state.trajectoryData}
                target={this.state.target}
                r={this.state.r}
              />
            </div>
          </div>
        </div>
        <hr />
        <Instructions />
        <hr />
        <About />
        <hr />
        <Footer />
      </div>
    );
  }
}

export default App;
