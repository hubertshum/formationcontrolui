import React from "react";
import Header from "./Header.js";
import Footer from "./Footer.js";
import PlotlyFig from "./Visualisation.js";
import Instructions from "./Instructions.js";
import "bootstrap/dist/css/bootstrap.css";
import "./App.css";

function query_builder(url, params) {
  // function to build query strings for hashmap
  let query = Object.keys(params)
    .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
    .join("&");

  let qUrl = url + "?" + query;
  return qUrl;
}

function About() {
  return (
    <div>
      <h3>About</h3>
      <p>
        This application visualizes the flight paths of UAVs in a hemispherical
        formation as they track toward a target. It is built on top of a new AI
        formation control algorithm called Flux Guiding. The algorithm is
        packaged{" "}
        <a href="https://gitfront.io/r/johnmatthewhartley/c81e9e54cb2749d718e54ae6517bca517097e1ae/formationplanning/">
          here
        </a>
        .
      </p>
      <p>
        The principle idea is that a formation can be led by maximizing the sum
        of an electric field or flux across its surface generated by a target.
        Since the field is harmonic the formation will orientate itself toward
        and track the target.
      </p>
      <p>
        The algorithm is efficient since only the UAVs on the front face of the
        formation are required to measure the flux and therefore many followers
        can be added to the formation without increasing the dimensionality of
        the problem. Also the algorithm is ideal for applications where the
        formation must maximally cover the target.
      </p>
    </div>
  );
}

function Intro() {
  return (
    <p className="lead">
      Model the flight of a UAV formation tasked with tracking and surrounding a
      remote target.
    </p>
  );
}

class Slider extends React.Component {
  constructor(props) {
    super(props);
    this.state = { value: 0 };
  }

  render() {
    return (
      <div>
        <label className="form-label">
          {this.props.name}: {this.props.value}
        </label>
        <input
          step="1"
          value={this.props.value}
          min={this.props.min}
          max={this.props.max}
          type="range"
          className="form-range blue-dial"
          onChange={(e) => this.props.onChange(e)}
        />
      </div>
    );
  }
}

class UpdateButton extends React.Component {
  render() {
    //let msg = this.props.loading ? 'Running...': 'Run'
    return (
      <div className="p-bottom p-top">
        <button
          type="button"
          className="jh-btn-primary btn btn-primary"
          onClick={(e) => this.props.onClick(e)}
        >
          {this.props.loading}
        </button>
      </div>
    );
  }
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      // default values for the sliders
      values: [10, -20, 20, 5, 0, 0, 0, 5],
      // min values for the sliders
      min: [-50, -50, -50, 1, 0, 0, 0, 5],
      // max values for the sliders
      max: [50, 50, 50, 20, 50, 50, 50, 10],
      // names for the sliders
      names: [
        "Target X",
        "Target Y",
        "Target Z",
        "Target Radius",
        "Formation X",
        "Formation Y",
        "Formation Z",
        "Formation Scale",
      ],
      // the data for the uav trajectories
      trajectoryData: null,
      // message for whether we are loading trajectory data
      loading: "",
    };
  }

  handleChange(i, e) {
    // handle slider change event
    const values = this.state.values.slice();
    values[i] = parseInt(e.target.value, 10);
    this.setState({ values: values });
    e.target.blur();
  }

  handleButtonClick(e) {
    // handle the button click event
    this.fetchTrajectoryData();
    e.target.blur();
  }

  figureLoaded() {
    // run when Plotly digure has been updated.
    this.setState({ loading: "Run" });
  }

  fetchTrajectoryData() {
    // ajax request for trajectory data
    this.setState({ loading: "Loading..." });

    let params = {
      target: this.state.values.slice(0, 3),
      formation: this.state.values.slice(4, 7),
      r: this.state.values.slice(3, 4),
      sep: this.state.values.slice(7),
    };

    let url = query_builder(process.env.REACT_APP_API_URL + "/api/xt", params);

    fetch(url)
      .then((response) => {
        if (!response.ok) {
          throw Error(response.statusText);
        }
        return response.json();
      })
      .then(
        this.setState({
          target: params["target"],
          r: params["r"],
        })
      )
      .then((data) => this.setState({ trajectoryData: data["trajectory"] }))
      .catch((error) => {
        if (process.env.NODE_ENV === "development") {
          console.error(error);
        }
      });
  }

  renderRange(i) {
    // helper function to render the slider
    return (
      <Slider
        name={this.state.names[i]}
        value={this.state.values[i]}
        onChange={(e) => this.handleChange(i, e)}
        min={this.state.min[i]}
        max={this.state.max[i]}
      />
    );
  }

  componentDidMount() {
    // after render then load some data for the user.
    this.fetchTrajectoryData();
  }

  render() {
    return (
      <div className="App">
        <Header />
        <div className="container space-up-down">
          <Intro />
          <div className="row">
            <div className="col-sm-2">
              {this.renderRange(0)}
              {this.renderRange(1)}
              {this.renderRange(2)}
              {this.renderRange(3)}
              {this.renderRange(4)}
              {this.renderRange(5)}
              {this.renderRange(6)}
              {this.renderRange(7)}
              <UpdateButton
                onClick={(e) => this.handleButtonClick(e)}
                loading={this.state.loading}
              />
            </div>
            <div className="col-sm-10">
              <PlotlyFig
                onChange={() => this.figureLoaded()}
                tdata={this.state.trajectoryData}
                target={this.state.target}
                r={this.state.r}
              />
            </div>
          </div>

          <Instructions />
          <About />
        </div>
        <Footer />
      </div>
    );
  }
}

export default App;
